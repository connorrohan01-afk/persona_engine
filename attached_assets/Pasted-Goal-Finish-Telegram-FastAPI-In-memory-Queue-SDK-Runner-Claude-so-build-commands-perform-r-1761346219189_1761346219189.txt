Goal: Finish Telegram ‚Üí FastAPI ‚Üí In-memory Queue ‚Üí SDK Runner (Claude) so /build commands perform real file reads/writes, show diffs/hashes, and support approvals for protected files. Keep everything in one FastAPI process on port 5000.

Do this exactly:
	1.	Dependencies: ensure anthropic, fastapi, uvicorn, python-telegram-bot==13.* (or keep our raw HTTP calls), and httpx are installed.
	‚Ä¢	If using requirements.txt, add them; if using Poetry, add them to pyproject.toml.
	2.	Project layout (create/update files):

app/server.py                 # FastAPI + routes + worker + telegram handlers
sdk/runner.py                 # Claude helpers (plan/patch)
utils/files.py                # read/write helpers
utils/tests.py                # tiny smoke tests
tools/reset_webhook.py        # set/delete/verify Telegram webhook for our public repl URL

3.	server.py: Single process app with:
	‚Ä¢	global thread-safe queue TASK_QUEUE = queue.Queue()
	‚Ä¢	background worker thread started on startup; it .get()s jobs and calls sdk.runner functions
	‚Ä¢	routes:
	‚Ä¢	GET /api/v1/health ‚Üí {ok:true, queue_depth:n, time:...}
	‚Ä¢	GET /api/v1/telegram/info ‚Üí live webhook status (call Telegram getWebhookInfo)
	‚Ä¢	POST /api/v1/telegram/{token} ‚Üí webhook; parse message text; dispatch commands
	‚Ä¢	Commands (from Telegram text):
	‚Ä¢	/ping ‚Üí reply ‚Äú‚úÖ Direct test pong‚Äù
	‚Ä¢	/status ‚Üí reply with worker status + queue depth
	‚Ä¢	/build read <path> ‚Üí reply with first 1200 chars + SHA1
	‚Ä¢	/build read_hash <path> ‚Üí reply with SHA1 only
	‚Ä¢	/build diff <path> ‚Üí reply with git diff -- <path> (first ~120 lines)
	‚Ä¢	/build patch <path> ‚Üí expect the next user message to contain a spec:

goal: ...
tests:
- ...
- ...

Enqueue a job {type:"patch", path, goal, tests}. Return ‚Äúüõ† Queued build: ‚Äù.

	‚Ä¢	Optional approvals: keep a list PROTECTED = ["app/server.py","sdk/runner.py"].
If patch targets a protected file, reply ‚Äúüõë Needs approval: /approve <job_id>‚Äù.
/approve <job_id> enqueues it; /reject <job_id> drops it.

	‚Ä¢	Logging: print inbound Telegram text, job IDs, writes, and test results.

	4.	utils/files.py:
	‚Ä¢	read_text(path) / write_text(path, text) (UTF-8)
	‚Ä¢	sha1(path) returns hex or "MISSING"
	‚Ä¢	git_diff(path, max_lines=120) returns git diff snippet (or ‚Äú(no diff)‚Äù)
	5.	utils/tests.py:
	‚Ä¢	run_smoke_tests():
	‚Ä¢	try to import test_sample and call a trivial function if present; else return True,"PASS(no tests)"
	6.	sdk/runner.py (use ANTHROPIC_API_KEY):
	‚Ä¢	plan(prompt:str)->str using claude-3-5-sonnet-20241022
	‚Ä¢	patch_file(path:str, goal:str, tests:list[str]):
	‚Ä¢	read original file
	‚Ä¢	prompt Claude: ‚ÄúYou are a code editor. Return ONLY the full new file content. File: {path}. Goal: {goal}. Original:\n‚Äô‚Äô‚Äô{original}‚Äô‚Äô‚Äô‚Äù
	‚Ä¢	write new text
	‚Ä¢	run run_smoke_tests()
	‚Ä¢	return dict {ok, lines_changed, note}
	‚Ä¢	Keep it deterministic; no tool calls.
	7.	tools/reset_webhook.py:
	‚Ä¢	Detect the public Replit URL (env REPLIT_PUBLIC_URL if available; else instruct to paste)
	‚Ä¢	Delete old webhook, set new webhook to
https://<PUBLIC_URL>/api/v1/telegram/${TELEGRAM_BOT_TOKEN}
	‚Ä¢	Print the result of getWebhookInfo
	8.	Secrets: use environment vars already present:
	‚Ä¢	TELEGRAM_BOT_TOKEN, CHAT_ID_DEFAULT, ANTHROPIC_API_KEY
	9.	Startup:
	‚Ä¢	Uvicorn at 0.0.0.0:5000, lifespan start: start worker thread and print ‚ÄúWorker running‚Äù.
	10.	Tests to run automatically after changes (and show in console):
	‚Ä¢	Call GET /api/v1/health (expect ok:true)
	‚Ä¢	tools/reset_webhook.py to ensure Telegram points to this deployment
	‚Ä¢	Simulate inbound Telegram JSON to /api/v1/telegram/{token} for:
	‚Ä¢	/ping (expect reply)
	‚Ä¢	/build read test_sample.py (expect content + SHA1)
	‚Ä¢	/build patch test_canary.txt with spec:

goal: overwrite file with:
CANARY: {{timestamp}} :: proving write OK

‚Ä¢	/build read test_canary.txt (expect CANARY line)
	‚Ä¢	/build patch test_sample.py (append blank line only) then /build diff test_sample.py (expect 1 line diff)

	11.	Important: Do NOT echo secrets in logs or replies. If a command fails, reply with a concise error and print full traceback only in Replit console.
	12.	Deliverables: Commit all files; show a short summary listing:
	‚Ä¢	Active routes
	‚Ä¢	Commands supported
	‚Ä¢	Webhook URL in use
	‚Ä¢	Sample transcript from console: inbound ‚Üí queued ‚Üí worker write ‚Üí test result ‚Üí telegram reply.

After you finish, restart the app and confirm in console:

‚úÖ Worker thread started
‚úÖ Webhook set ‚Üí https://<public>/api/v1/telegram/<token>

I‚Äôll then run from Telegram:

/ping
/build read app/server.py
/build patch test_canary.txt
goal: overwrite file with: CANARY OK
/build read test_canary.txt
/build patch test_sample.py
goal: append blank line only
/build diff test_sample.py
All of these must succeed and show real file changes (hash/diff) and logs.
