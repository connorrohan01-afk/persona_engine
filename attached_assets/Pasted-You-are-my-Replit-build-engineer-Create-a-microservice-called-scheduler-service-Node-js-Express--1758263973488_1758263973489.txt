You are my Replit build engineer. Create a microservice called scheduler-service (Node.js + Express) that manages scheduled tasks for accounts (posting, warming, keep-alives). This service must NOT call any external sites; it only stores schedules, simulates triggers, and exposes endpoints for CRUD. Think of it as a safe orchestration layer for account activities.

Requirements:
	•	Tech: Node 18+, Express, helmet, morgan, express-rate-limit, zod, nanoid.
	•	Structure: server.js, src/lib/{auth,validators,store}.js, src/routes/{schedules}.js, README.md, package.json.
	•	Auth: Bearer header via AUTH_BEARER_TOKEN (default fallback: scheduler_token_123).
	•	Storage: In-memory map of schedules { id, accountId, type: “post”|“warm”|“keepalive”, cronExpr, payload, status: “active”|“paused”, createdAt, updatedAt }.
	•	Endpoints under /api/v1. Include /health and print AVAILABLE_ROUTES at boot.
	•	Rate limit: 200 req / 5 min default.
	•	All JSON responses must use envelope { ok:true|false, data?, error? }.
	•	Simulated executor: when POST /schedules/:id/execute is called, log “Executing schedule {id} type={type} payload=…” and update status history.
	•	README with curl examples.

Files to create (full contents):

package.json
{
“name”: “scheduler-service”,
“private”: true,
“type”: “module”,
“scripts”: {
“dev”: “node server.js”
},
“dependencies”: {
“express”: “^4.19.2”,
“helmet”: “^7.0.0”,
“morgan”: “^1.10.0”,
“express-rate-limit”: “^7.2.0”,
“zod”: “^3.23.8”,
“nanoid”: “^5.0.7”
}
}

server.js
import express from ‘express’;
import helmet from ‘helmet’;
import morgan from ‘morgan’;
import rateLimit from ‘express-rate-limit’;
import { bearerAuth } from ‘./src/lib/auth.js’;
import schedulesRouter from ‘./src/routes/schedules.js’;

const app = express();
const PORT = process.env.PORT || 3000;

app.use(helmet());
app.use(morgan(‘tiny’));
app.use(express.json({ limit: ‘1mb’ }));

const limiter = rateLimit({ windowMs: 5 * 60 * 1000, max: 200, standardHeaders: true });
app.use(limiter);

app.get(’/api/v1/health’, (req, res) => {
res.json({ ok: true, data: { service: ‘scheduler-service’, status: ‘healthy’ } });
});

app.use(’/api/v1/schedules’, bearerAuth, schedulesRouter);

app.use((req, res) => res.status(404).json({ ok: false, error: { message: ‘not_found’ } }));

function printRoutes() {
const routes = [];
app._router.stack.forEach((m) => {
if (m.route && m.route.path) {
const methods = Object.keys(m.route.methods).map(m => m.toUpperCase()).join(’,’);
routes.push(${methods.padEnd(6)} ${m.route.path});
} else if (m.name === ‘router’ && m.handle.stack) {
m.handle.stack.forEach((h) => {
if (h.route) {
const methods = Object.keys(h.route.methods).map(m => m.toUpperCase()).join(’,’);
routes.push(${methods.padEnd(6)} ${m.regexp}${h.route.path});
}
});
}
});
console.log(‘AVAILABLE_ROUTES’);
routes.sort().forEach(r => console.log(r));
}

app.listen(PORT, () => {
console.log(scheduler-service listening on :${PORT});
printRoutes();
console.log(‘READY’);
});

export default app;

src/lib/auth.js
export function bearerAuth(req, res, next) {
const header = req.headers[‘authorization’] || ‘’;
const token = header.startsWith(’Bearer ’) ? header.slice(7) : null;
const allow = process.env.AUTH_BEARER_TOKEN || ‘scheduler_token_123’;
if (!token || token !== allow) {
return res.status(401).json({ ok: false, error: { message: ‘unauthorized’ } });
}
req.user = { ok: true, sandbox: true };
next();
}

src/lib/validators.js
import { z } from ‘zod’;

export const ScheduleCreateSchema = z.object({
accountId: z.string().min(1),
type: z.enum([‘post’,‘warm’,‘keepalive’]),
cronExpr: z.string().min(1),
payload: z.record(z.any()).optional(),
status: z.enum([‘active’,‘paused’]).default(‘active’)
});

export const SchedulePatchSchema = z.object({
type: z.enum([‘post’,‘warm’,‘keepalive’]).optional(),
cronExpr: z.string().optional(),
payload: z.record(z.any()).optional(),
status: z.enum([‘active’,‘paused’]).optional()
});

export function parse(schema, body) {
const r = schema.safeParse(body);
if (!r.success) {
return { ok: false, error: r.error.flatten() };
}
return { ok: true, data: r.data };
}

src/lib/store.js
import { nanoid } from ‘nanoid’;

const schedules = new Map();

export function createSchedule(payload) {
const id = nanoid();
const now = new Date().toISOString();
const s = { id, createdAt: now, updatedAt: now, …payload };
schedules.set(id, s);
return s;
}

export function listSchedules({ offset = 0, limit = 50 } = {}) {
const all = Array.from(schedules.values());
return { total: all.length, items: all.slice(offset, offset + limit) };
}

export function getSchedule(id) { return schedules.get(id) || null; }

export function patchSchedule(id, patch) {
const cur = schedules.get(id);
if (!cur) return null;
const updated = { …cur, …patch, updatedAt: new Date().toISOString() };
schedules.set(id, updated);
return updated;
}

export function deleteSchedule(id) { return schedules.delete(id); }

src/routes/schedules.js
import { Router } from ‘express’;
import { parse, ScheduleCreateSchema, SchedulePatchSchema } from ‘../lib/validators.js’;
import { createSchedule, listSchedules, getSchedule, patchSchedule, deleteSchedule } from ‘../lib/store.js’;

const r = Router();

r.post(’/’, (req, res) => {
const v = parse(ScheduleCreateSchema, req.body || {});
if (!v.ok) return res.status(400).json({ ok: false, error: v.error });
const created = createSchedule(v.data);
res.json({ ok: true, data: created });
});

r.get(’/’, (req, res) => {
const offset = Number(req.query.offset || 0) || 0;
const limit = Math.min(Number(req.query.limit || 50) || 50, 200);
const list = listSchedules({ offset, limit });
res.json({ ok: true, data: list });
});

r.get(’/:id’, (req, res) => {
const s = getSchedule(req.params.id);
if (!s) return res.status(404).json({ ok: false, error: { message: ‘not_found’ } });
res.json({ ok: true, data: s });
});

r.patch(’/:id’, (req, res) => {
const v = parse(SchedulePatchSchema, req.body || {});
if (!v.ok) return res.status(400).json({ ok: false, error: v.error });
const updated = patchSchedule(req.params.id, v.data);
if (!updated) return res.status(404).json({ ok: false, error: { message: ‘not_found’ } });
res.json({ ok: true, data: updated });
});

r.delete(’/:id’, (req, res) => {
const ok = deleteSchedule(req.params.id);
if (!ok) return res.status(404).json({ ok: false, error: { message: ‘not_found’ } });
res.json({ ok: true, data: { id: req.params.id, deleted: true } });
});

r.post(’/:id/execute’, (req, res) => {
const s = getSchedule(req.params.id);
if (!s) return res.status(404).json({ ok: false, error: { message: ‘not_found’ } });
console.log([EXECUTE] schedule ${s.id} type=${s.type} payload=${JSON.stringify(s.payload)});
res.json({ ok: true, data: { id: s.id, executed: true } });
});

export default r;

README.md

scheduler-service

Simple scheduler for accounts. Stores schedule metadata (post, warm, keepalive) and simulates execution. No external calls.

Env
	•	AUTH_BEARER_TOKEN (default: scheduler_token_123)
	•	PORT=3000

Run

npm run dev

Health (no auth)

curl -s https://.replit.app/api/v1/health

Auth header

Authorization: Bearer scheduler_token_123

Example flow

Create schedule:
curl -s -X POST https://.replit.app/api/v1/schedules -H “Authorization: Bearer scheduler_token_123” -H “Content-Type: application/json” -d ‘{“accountId”:“a1”,“type”:“post”,“cronExpr”:“0 * * * *”,“payload”:{“text”:“hello”}}’

Execute schedule:
curl -s -X POST https://.replit.app/api/v1/schedules//execute -H “Authorization: Bearer scheduler_token_123”