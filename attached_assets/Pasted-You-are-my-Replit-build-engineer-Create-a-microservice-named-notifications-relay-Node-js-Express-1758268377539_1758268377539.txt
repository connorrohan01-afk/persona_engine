You are my Replit build engineer. Create a microservice named notifications-relay (Node.js + Express) that safely fan-outs internal events (status changes, job results, alerts) to user-approved channels. Default to MOCK adapters (no external sends). When env creds are present, enable Telegram Bot and SMTP email adapters. No rate-limit evasion or bulk/unsolicited messaging features.

REQUIREMENTS
• Tech: Node 18+, Express, helmet, morgan, express-rate-limit, zod, nanoid, nodemailer, axios.
• Structure: server.js, src/lib/{auth,validators}.js, src/adapters/{telegram,email,mock}.js, src/routes/{notify,health}.js, README.md, package.json.
• Auth: Bearer via AUTH_BEARER_TOKEN (default relay_token_123).
• Envelope: all JSON → { ok: true|false, data?, error? }.
• Rate limit: 300 req / 5 min.
• Health: GET /api/v1/health (no auth).
• Endpoints (auth required):
  - POST /api/v1/notify/test { channel, to, message }
  - POST /api/v1/notify/event { type, severity?, message, meta?, channels:[{channel,to}] }
  - GET  /api/v1/notify/adapters → report which adapters are active (mock/telegram/email)
• Adapters:
  - MOCK (always on): logs payload (no external call).
  - TELEGRAM (enable if TELEGRAM_BOT_TOKEN set): send text via https://api.telegram.org/bot<token>/sendMessage to chat_id.
  - EMAIL (enable if SMTP_HOST/SMTP_USER/SMTP_PASS set): send via nodemailer (TLS), from RELAY_FROM (default “Notifications <no-reply@example.com>”).
• Observability: print AVAILABLE_ROUTES on boot; log each dispatch attempt with a nanoid dispatch id.
• Safety: refuse sends with >1000 chars message or missing “to” for a channel; reject bulk lists over 50 recipients.

FILES TO CREATE (exact contents)

package.json
json
{
  "name": "notifications-relay",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "node server.js"
  },
  "dependencies": {
    "axios": "^1.7.7",
    "express": "^4.19.2",
    "express-rate-limit": "^7.2.0",
    "helmet": "^7.0.0",
    "morgan": "^1.10.0",
    "nanoid": "^5.0.7",
    "nodemailer": "^6.9.14",
    "zod": "^3.23.8"
  }
}

server.js
js
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';
import rateLimit from 'express-rate-limit';
import healthRouter from './src/routes/health.js';
import notifyRouter from './src/routes/notify.js';
import { bearerAuth } from './src/lib/auth.js';

const app = express();
const PORT = process.env.PORT || 3000;

app.use(helmet());
app.use(morgan('tiny'));
app.use(express.json({ limit: '1mb' }));

const limiter = rateLimit({ windowMs: 5 * 60 * 1000, max: 300, standardHeaders: true });
app.use(limiter);

// Health (no auth)
app.use('/api/v1/health', healthRouter);

// Protected
app.use('/api/v1/notify', bearerAuth, notifyRouter);

// 404
app.use((req, res) => res.status(404).json({ ok: false, error: { message: 'not_found' } }));

function printRoutes() {
  const routes = [];
  const scan = (stack, base = '') => {
    stack.forEach((l) => {
      if (l.route) {
        const m = Object.keys(l.route.methods).map(x => x.toUpperCase()).join(',');
        routes.push(`${m.padEnd(6)} ${base}${l.route.path}`);
      } else if (l.name === 'router' && l.handle?.stack) {
        scan(l.handle.stack, base);
      }
    });
  };
  scan(app._router.stack);
  console.log('AVAILABLE_ROUTES');
  routes.sort().forEach(r => console.log(r));
}

app.listen(PORT, () => {
  console.log(`notifications-relay listening on :${PORT}`);
  printRoutes();
  console.log('READY: notifications-relay');
});

export default app;

src/lib/auth.js
js
export function bearerAuth(req, res, next) {
  const header = req.headers['authorization'] || '';
  const token = header.startsWith('Bearer ') ? header.slice(7) : null;
  const allow = process.env.AUTH_BEARER_TOKEN || 'relay_token_123';
  if (!token || token !== allow) {
    return res.status(401).json({ ok: false, error: { message: 'unauthorized' } });
  }
  req.user = { ok: true, role: 'relay' };
  next();
}

src/lib/validators.js
js
import { z } from 'zod';

export const ChannelRef = z.object({
  channel: z.enum(['mock','telegram','email']),
  to: z.union([z.string().min(1), z.number()]) // chat_id/email etc.
});

export const NotifyTestSchema = z.object({
  channel: z.enum(['mock','telegram','email']),
  to: z.union([z.string().min(1), z.number()]),
  message: z.string().min(1).max(1000)
});

export const NotifyEventSchema = z.object({
  type: z.string().min(1),
  severity: z.enum(['info','warn','error']).optional(),
  message: z.string().min(1).max(1000),
  meta: z.record(z.any()).optional(),
  channels: z.array(ChannelRef).min(1).max(50)
});

export function parse(schema, body) {
  const r = schema.safeParse(body);
  if (!r.success) return { ok: false, error: r.error.flatten() };
  return { ok: true, data: r.data };
}

src/adapters/mock.js
js
import { nanoid } from 'nanoid';
export async function sendMock({ to, message, meta }) {
  const id = nanoid();
  console.log('[MOCK SEND]', id, { to, message, meta });
  return { ok: true, id, adapter: 'mock' };
}
export function active() { return true; }

src/adapters/telegram.js
js
import axios from 'axios';
import { nanoid } from 'nanoid';

function getToken() { return process.env.TELEGRAM_BOT_TOKEN || null; }
export function active() { return !!getToken(); }

export async function sendTelegram({ to, message }) {
  const token = getToken();
  if (!token) return { ok: false, error: 'telegram_disabled' };
  const id = nanoid();
  try {
    const url = `https://api.telegram.org/bot${token}/sendMessage`;
    const res = await axios.post(url, {
      chat_id: String(to),
      text: String(message)
    }, { headers: { 'Content-Type': 'application/json' } });
    return { ok: true, id, adapter: 'telegram', data: res.data };
  } catch (e) {
    return { ok: false, error: e?.message || 'telegram_send_failed' };
  }
}

src/adapters/email.js
js
import nodemailer from 'nodemailer';
import { nanoid } from 'nanoid';

let cached = null;
function getTransport() {
  if (cached) return cached;
  const host = process.env.SMTP_HOST;
  const port = Number(process.env.SMTP_PORT || 587);
  const user = process.env.SMTP_USER;
  const pass = process.env.SMTP_PASS;
  if (!host || !user || !pass) return null;
  cached = nodemailer.createTransport({
    host, port, secure: port === 465,
    auth: { user, pass }
  });
  return cached;
}

export function active() { return !!getTransport(); }

export async function sendEmail({ to, message }) {
  const t = getTransport();
  if (!t) return { ok: false, error: 'email_disabled' };
  const id = nanoid();
  const from = process.env.RELAY_FROM || 'Notifications <no-reply@example.com>';
  try {
    const info = await t.sendMail({
      from, to: String(to), subject: 'Notification', text: String(message)
    });
    return { ok: true, id, adapter: 'email', data: { messageId: info.messageId } };
  } catch (e) {
    return { ok: false, error: e?.message || 'email_send_failed' };
  }
}

src/routes/health.js
js
import { Router } from 'express';
const r = Router();
r.get('/', (_req, res) => res.json({ ok: true, data: { service: 'notifications-relay', status: 'healthy' } }));
export default r;

src/routes/notify.js
js
import { Router } from 'express';
import { parse, NotifyTestSchema, NotifyEventSchema } from '../lib/validators.js';
import { active as mockOn, sendMock } from '../adapters/mock.js';
import { active as tgOn, sendTelegram } from '../adapters/telegram.js';
import { active as emOn, sendEmail } from '../adapters/email.js';

const r = Router();

function adapterStatus() {
  return {
    mock: mockOn(),
    telegram: tgOn(),
    email: emOn()
  };
}

async function dispatchOne({ channel, to, message, meta }) {
  if (channel === 'mock') return sendMock({ to, message, meta });
  if (channel === 'telegram') return sendTelegram({ to, message, meta });
  if (channel === 'email') return sendEmail({ to, message, meta });
  return { ok: false, error: 'unknown_channel' };
}

r.get('/adapters', (_req, res) => res.json({ ok: true, data: adapterStatus() }));

r.post('/test', async (req, res) => {
  const v = parse(NotifyTestSchema, req.body || {});
  if (!v.ok) return res.status(400).json({ ok: false, error: v.error });
  const out = await dispatchOne(v.data);
  const code = out.ok ? 200 : 502;
  res.status(code).json({ ok: !!out.ok, data: out.ok ? out : undefined, error: out.ok ? undefined : { message: out.error } });
});

r.post('/event', async (req, res) => {
  const v = parse(NotifyEventSchema, req.body || {});
  if (!v.ok) return res.status(400).json({ ok: false, error: v.error });
  const results = [];
  for (const ch of v.data.channels) {
    const r = await dispatchOne({ ...ch, message: v.data.message, meta: { type: v.data.type, severity: v.data.severity, ...(v.data.meta||{}) } });
    results.push({ channel: ch.channel, to: ch.to, ok: r.ok, error: r.ok ? null : r.error });
  }
  const anyFail = results.some(x => !x.ok);
  res.status(anyFail ? 207 : 200).json({ ok: !anyFail, data: { results } });
});

export default r;

README.md
md
# notifications-relay

Small relay that forwards internal events to Telegram or Email, with a safe MOCK default.

## Env
- AUTH_BEARER_TOKEN (default `relay_token_123`)
- TELEGRAM_BOT_TOKEN (optional; enable Telegram)
- SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS (optional; enable Email)
- RELAY_FROM (optional; default "Notifications <no-reply@example.com>")
- PORT (default 3000)

## Run
npm run dev

## Health
curl -s https://<your-repl>.replit.app/api/v1/health

## Test (MOCK, no external sends)
curl -s -X POST https://<your-repl>.replit.app/api/v1/notify/test \
  -H "Authorization: Bearer relay_token_123" -H "Content-Type: application/json" \
  -d '{"channel":"mock","to":"demo","message":"hello from relay"}'

## Telegram (requires TELEGRAM_BOT_TOKEN)
curl -s -X POST https://<your-repl>.replit.app/api/v1/notify/test \
  -H "Authorization: Bearer relay_token_123" -H "Content-Type: application/json" \
  -d '{"channel":"telegram","to":7484907544,"message":"it works ✅"}'

## Email (requires SMTP env)
curl -s -X POST https://<your-repl>.replit.app/api/v1/notify/test \
  -H "Authorization: Bearer relay_token_123" -H "Content-Type: application/json" \
  -d '{"channel":"email","to":"you@example.com","message":"it works ✅"}'

## Multi-channel event
curl -s -X POST https://<your-repl>.replit.app/api/v1/notify/event \
  -H "Authorization: Bearer relay_token_123" -H "Content-Type: application/json" \
  -d '{"type":"cluster.activate","severity":"info","message":"Cluster A live","channels":[{"channel":"mock","to":"log"},{"channel":"telegram","to":7484907544}]}'